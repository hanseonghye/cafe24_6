[용어 정리]
HTTP status code
1) 정보 응답
100 지금까지 상태 양호 / 클라이언트 추가 요청 가능
101 클라이언트가 보낸 upgrade 요청 헤더에 대한 응답 / 서버에서 프로토콜 변경 통보
102 요청 처리 중

2) 성공 응답
200 OK 요청 수행 / GET(리소스 수신), PUT(리소스 변경), POST(리소스 생성)
201 Created 주로 PUT, POST에 대한 수행 결과
202 Accepted 요청은 수신했지만, 응답 과정에서 지연 발생

3) 리다이렉션 메시지
300 Multiple Choice 요청에 대한 응답 방법이 여러개라 특정하지 못한 상태
301 Moved Permanently 요청 리소스의 URI가 변경 됨
302 Found 요청 리소스의 URI가 일시적으로 변경 됨

4) 클라이언트 에러 응답
400 Bad Request 잘못된 문법으로 서버가 요청 이해하지 못함
401 Unauthorized 클라이언트 미인증 상태
404 Not Found 요청 받은 리소스 탐색 실패

5) 서버 에러 응답
500 Internal Server Error 서버가 처리 방법을 모르는 상황

pragma = HTTP/1.0 버전에서 Cache-Control 헤더가 생기기 전 그것과 동일한 역할을 하는 헤더

[HTTP 프로토콜의 특징]
1) 비연결지향
기본적으로 요청에 대한 응답이 완료되면 연결이 종료됨
1.1버전부터 헤더에 keep-alive라는 값을 추가해 연결을 재활용 하고 있음
비연결지향은 연결에 대한 리소스 낭비는 줄어들지만 재연결시 지속적으로 인증해야 하는 단점 존재
2) 상태정보 유지 X

→ 위 두가지 특징을 보완하기 위해 쿠키와 세션 등장

[쿠키]
(정의) 클라이언트 로컬에 저장되는 키:값 형태의 데이터 파일
(목적) 주로 현재 클라이언트의 상태 정보를 저장
(처리) 재요청 시 요청+쿠키값 함께 전송
(사례) 자동로그인 및 팝업 창 그만 띄우기
응답 헤더에 setCookie로 생성

[세션]
(정의) 일정 시간 동일한 브라우저로 요청되는 사항을 하나의 상태로 보고 그 상태 유지
(처리)
요청을 받은 서버가 클라이언트에게 고유한 ID를 부여
서버에서는 발급해준 ID를 쿠키로 저장(JSESSIONID)
(사례) 로그인 상태 유지

[쿠키와 세션의 차이]
1) 보안
쿠키의 경우 로컬에 저장되기 때문에 변질되거나 요청 과정에서 스나이핑 당할 우려가 있음
세션의 경우 ID만 저장한 후 그것을 토대로 서버에서 처리하기 때문에 보안이 우수

2) 라이프 사이클
쿠키의 경우 지정 가능
세션도 지정 가능하지만 브라우저 종료 시 자동 소멸

3) 속도
쿠키 > 세션(서버에서 처리)

[쿠키 사용 이유]
세션의 사용량이 많아지면 서버 메모리 부족 및 속도 저하 야기

[쿠키 / 세션 / 캐시]
캐시는 이미지 / css / js 파일 등이 클라이언트 브라우저에 저장되는 것
만약 서버에서 변경사항이 있을 시 캐시를 지워주거나 응답 헤더에 캐시 만료시간 명시